(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{648:function(e,v,_){"use strict";_.r(v);var l=_(7),o=Object(l.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#一、devops核心要点概述"}},[e._v("一、Devops核心要点概述")]),_("ul",[_("li",[_("a",{attrs:{href:"#_1-1、docker编排概述"}},[e._v("1.1、docker编排概述")])])])]),_("li",[_("a",{attrs:{href:"#_1-2、kubernetes官方概述特性"}},[e._v("1.2、Kubernetes官方概述特性")]),_("ul",[_("li",[_("a",{attrs:{href:"#_1-3、kubernetes架构及环境术语"}},[e._v("1.3、Kubernetes架构及环境术语")])])])]),_("li",[_("a",{attrs:{href:"#二、kunbernetes基础概念"}},[e._v("二、Kunbernetes基础概念")]),_("ul",[_("li",[_("a",{attrs:{href:"#_2-1、深度思考"}},[e._v("2.1、深度思考")])])])])])]),_("p"),e._v(" "),_("blockquote",[_("p",[e._v("Confluence : 由 zhe.dai创建, 最后修改于十一月 04, 2020")])]),e._v(" "),_("p",[_("img",{attrs:{src:"https://img2020.cnblogs.com/blog/1600332/202105/1600332-20210511224249270-1757175601.png",alt:"image"}})]),e._v(" "),_("h2",{attrs:{id:"一、devops核心要点概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、devops核心要点概述"}},[e._v("#")]),e._v(" 一、Devops核心要点概述")]),e._v(" "),_("h3",{attrs:{id:"_1-1、docker编排概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、docker编排概述"}},[e._v("#")]),e._v(" 1.1、docker编排概述")]),e._v(" "),_("ul",[_("li",[e._v("docker编排工具\n"),_("ul",[_("li",[e._v("docker自身的编排工具：\n"),_("ul",[_("li",[e._v("docker compose  ：适用于一个机器上的容器管理，面向一台宿主机，而不适用于面向集群编排")]),e._v(" "),_("li",[e._v("docker  swam  : 可以理解为docker swam 是可以将多个docker host 整合为统一平台之下的管理机制的一个集群工具，能将多个docker host 提供计算的资源能够整合为一个资源池，当docker swam 去编排是面向整合池去编排，可以不去更在意此host 是什么样的docker 主机。")]),e._v(" "),_("li",[e._v("docker machine ：可以快速的将一个docker 主机加入到docker swam，也可以理解为可以将docker 主机快速的满足加入docker swam的先觉条件，从而能够成为docker集群的一份子一个预处理工具。")])])]),e._v(" "),_("li",[e._v("mesos , marathon")]),e._v(" "),_("li",[e._v("Kubernetes")])])]),e._v(" "),_("li",[e._v("Kubernetes：代码托管在github ：https://github.com/kubernetes")])]),e._v(" "),_("h2",{attrs:{id:"_1-2、kubernetes官方概述特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、kubernetes官方概述特性"}},[e._v("#")]),e._v(" 1.2、Kubernetes官方概述特性")]),e._v(" "),_("ul",[_("li",[e._v("Kuberneteste特性：\n"),_("ul",[_("li",[e._v("1、实现自动装箱：\n"),_("ul",[_("li",[e._v("基于资源依赖，及其其他约束可以自动完成容器的部署，而且不影响其可用性。")])])]),e._v(" "),_("li",[e._v("2、自愈能力、自我修复：\n"),_("ul",[_("li",[e._v("如果镜像是制作好的，可以实现容器秒级启动，当容器蹦了之后直接新启动一个容器完成秒级替换。")])])]),e._v(" "),_("li",[e._v("3、自动实现水平扩展\n"),_("ul",[_("li",[e._v("即一个容器不够再启动一个，可以不断的向上扩展必须有物理资源平台支持是足够的。")])])]),e._v(" "),_("li",[e._v("4、自动实现服务发现和负载均衡\n"),_("ul",[_("li",[e._v("当我们再k8s上运行很多应用程序时，如果已经使用微服务架构的时候服务和服务之间可以自动找到依赖到的服务，如果启动了多个以后，可以实现自动负载均衡。")])])]),e._v(" "),_("li",[e._v("5、自动发现和回滚操作\n"),_("ul",[_("li",[e._v("减轻运维的日常工作")])])]),e._v(" "),_("li",[e._v("6、密钥和配置管理\n"),_("ul",[_("li",[e._v("容器化运行的最大的问题就是我们所配置的容器内的应用程序比较多，很困难。")]),e._v(" "),_("li",[e._v("使用容器编排平台的外部的组建来保存项要使用的配置信息，当容器启动时，只需要让镜像去加载外部的配置中心中的配置，来完成容器内的配置，从而实现配置集中化。")])])]),e._v(" "),_("li",[e._v("7、存储编排\n"),_("ul",[_("li",[e._v("将存储卷实现动态供给")])])]),e._v(" "),_("li",[e._v("8、任务的批量处理执行")])])])]),e._v(" "),_("h3",{attrs:{id:"_1-3、kubernetes架构及环境术语"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3、kubernetes架构及环境术语"}},[e._v("#")]),e._v(" 1.3、Kubernetes架构及环境术语")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("k8s就是一个集群，来组合多台资源，整合成一个大的资源池，并统一对外提供计算等能力的集群。")])]),e._v(" "),_("li",[_("p",[e._v("集群说白了就是找许多台主机，每台主机上都安装上k8s应用的相关程序，并通过此应用程序协同工作，将多个主机当作一个主机使用，来完成彼此间的协同。")])]),e._v(" "),_("li",[_("p",[e._v("k8s集群中主机是分角色的：")]),e._v(" "),_("ul",[_("li",[e._v("集群有两种常用模型：\n"),_("ul",[_("li",[e._v("p2p : 如redis-cluster 每个节点都是主节点，同时工作（每个节点都可以直接路由用户请求）。")]),e._v(" "),_("li",[e._v("有中心节点的，如mysql主从，一个主节点一个从节点，从节点一直同步主节点数据。")])])])])]),e._v(" "),_("li",[_("p",[e._v("k8s就是属于一个有中心节点结构的集权系统，被称为master/nodes(worker)模型，一组节点扮演主节点（一般不需要太多，可以实现冗余/高可用大约三台机器即可），nodes节点是真正提供工作的节点即运行容器的节点。")])]),e._v(" "),_("li",[_("p",[e._v("客户端的请求先发送给master，master中有一个调度器，来分析各个nodes节点现有的可用资源状态，找一个最佳适配用户所请求的容器的节点并实现内部的容器运行。")])]),e._v(" "),_("li",[_("p",[e._v("下图为k8架构特点：")])])]),e._v(" "),_("p",[_("img",{attrs:{src:"https://img2020.cnblogs.com/blog/1600332/202105/1600332-20210511224649281-1715546711.png",alt:"image"}})]),e._v(" "),_("ul",[_("li",[_("p",[e._v("Master是最核心的资源之一（管理平面）")]),e._v(" "),_("ul",[_("li",[e._v("在Master之上有三个核心组件：\n"),_("ul",[_("li",[e._v("Api Server    ： 负责接收客户端请求，解析请求，响应请求")]),e._v(" "),_("li",[e._v("Scheduler    ：\n"),_("ul",[_("li",[e._v("调度器，负责观测每个Node节点上的 ，Ram、Cpu、和存储资源，并根据用户请求创建的容器的需要的资源量评估那个Node节点更适合运行此容器")]),e._v(" "),_("li",[e._v("K8s制作了两层调度模型：第一先根据上面条件进行预选即评估集群中所有的Node到底有哪些符合运行此容器的资源阈值，第二再从其选出的Node中选择最优的适配 （优选算法）")])])]),e._v(" "),_("li",[e._v("Controller-Manager ：\n"),_("ul",[_("li",[e._v("Master之上的可用性探测机制探测服务的可用性，一旦容器中的应用程序出现问题，Node之上会安装一个加入K8s集群的组件 Kuberlet 会确保此容器的运行状态")])])]),e._v(" "),_("li",[e._v("控制器应用程序\n"),_("ul",[_("li",[e._v("负责去监控所管理的每一个容器是否为健康的，如果发现不健康，则控制器去负责和Master发起请求，告知Master请求重新调度Scheduler重新启动新的容器")]),e._v(" "),_("li",[e._v("控制器需要在本地不段的进行Loop，周期性探测所管理的容器的状态，如果发现容器未达到用户对容器的期望运行状态，会尽可能的进行向用户的期望的容器运行状态进行迁移")])])]),e._v(" "),_("li",[e._v("控制器管理器\n"),_("ul",[_("li",[e._v("控制器管理器负责监控着每一个控制器的健康状态")]),e._v(" "),_("li",[e._v("控制器管理器做冗余，每个Master节点上都会安装其控制器管理器")])])])])])])]),e._v(" "),_("li",[_("p",[e._v("K8s运行的最小单元Pod")]),e._v(" "),_("ul",[_("li",[e._v("K8s之上最小运行单元并非叫做容器，而是叫做Pod。即K8s并非直接调度容器的运行，而调度的目标为Pod，Pod可以理解为容器的外壳。")]),e._v(" "),_("li",[e._v("Pod的工作特点：\n"),_("ul",[_("li",[e._v("K8s制作了一个逻辑组件叫Pod，再Pod用来运行容器，但是一个Pod内可以包含多个容器，这多个容器共享同一个底层网络名称空间。（可以理解为Pod是用来模拟传统虚拟机的。）")]),e._v(" "),_("li",[e._v("同一个Pod内的容器还可以共享第二种资源，叫做存储卷。")]),e._v(" "),_("li",[e._v("可以理解为存储卷不再属于容器而是属于Pod。但是一般说来一个Pod内仅存放一个容器，除非容器之间存在特别紧密的东西，必须放在同一个Pod内。另外如果再同一Pod中存在多个容器，通常有一个容器为主容器，其他容器是为了辅助主容器中的应用程序来完成更多功能来实现的。")])])])])]),e._v(" "),_("li",[_("p",[e._v("Label Selector 标签选择器：")]),e._v(" "),_("ul",[_("li",[e._v("（识别不同的Pod的数据及元数据K/V类型数据）Pod需要有标签来标识，可以使用Label Selector来根据需求来过滤Pod")]),e._v(" "),_("li",[e._v("标识是之后再K8s之上管理、分类、识别 的途径和凭凭证\n"),_("img",{attrs:{src:"https://img2020.cnblogs.com/blog/1600332/202105/1600332-20210511225056703-645457886.png",alt:"image"}})])])]),e._v(" "),_("li",[_("p",[e._v("Nodes")]),e._v(" "),_("ul",[_("li",[e._v("Nodes为K8s集群的工作节点")]),e._v(" "),_("li",[e._v("负责Master节点指派的职务，最根本的就是以Pod的形式来运行容器的。")])])]),e._v(" "),_("li",[_("p",[e._v("Nodes上的组件：")]),e._v(" "),_("ul",[_("li",[e._v("Kubelet：用于和Master通信和用于接收Master的调度来的各种任务并执行的称为集权代理。")]),e._v(" "),_("li",[e._v("容器引擎（Docker并不是唯一选择）")]),e._v(" "),_("li",[e._v("Kube-Proxy 随时与Api Server进行通讯，因为每一个Pod发生变化之后，状态结果是保存再Api Server中，当Pod运行状态发生改变之后，会再Api Server发生一个事件，此事件可以让任何关联得服务接收到，当前Kube-Proxy也会接收到，如果Pod发生改变地址发生改变则由Kube-Proxy负责在本地 反映到Iptables 或 Ipvs规则中。\n"),_("img",{attrs:{src:"https://img2020.cnblogs.com/blog/1600332/202105/1600332-20210511225140950-2110867295.png",alt:"image"}})])])])]),e._v(" "),_("h2",{attrs:{id:"二、kunbernetes基础概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、kunbernetes基础概念"}},[e._v("#")]),e._v(" 二、Kunbernetes基础概念")]),e._v(" "),_("h3",{attrs:{id:"_2-1、深度思考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、深度思考"}},[e._v("#")]),e._v(" 2.1、深度思考")]),e._v(" "),_("h4",{attrs:{id:"_2-2-1、pod控制器管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1、pod控制器管理"}},[e._v("#")]),e._v(" 2.2.1、pod控制器管理")]),e._v(" "),_("ul",[_("li",[e._v("1、当k8s之上运行pod之后，同一类pod可能不止一个，既然如此，当用户的请求到达时，如何接入用户请求，将交给哪一类pod介入或相应。")]),e._v(" "),_("li",[e._v("2、pod本身是有控制器管理，尽量不用人去管理，pod一般会分为两类：\n"),_("ul",[_("li",[e._v("自主式pod ：创建→API Server → 借助Scheduer调度器→ node节点启动此pod，如果node中的pod出现故障需要出现问题则由kubelet完成，如果容器出现问题则pod则消失不见，没办法自己实现调度。")]),e._v(" "),_("li",[e._v("管理器（pod控制器管理的pod）：借助pod管理器，就可以实现pod有生命周期的对象，由调度器调度到集群的某节点运行后，任务终止则pod被删除。\n"),_("ul",[_("li",[e._v("Replication Controller（副本控制器）：\n"),_("ul",[_("li",[e._v("当启动一个pod时，如果pod不够用了可以再启动一个，就称为副本，控制器则专门控制着pod同一类资源对象的各种副本。一旦发现副本数量缺少则回自动添加一个补充，多退少补机制，必须要精确人定义的副本数量。")]),e._v(" "),_("li",[e._v("滚动更新机制，pod容器中镜像更新迭代")])])]),e._v(" "),_("li",[e._v("ReplicaSet (在新版本中升级了控制器叫副本级控制器，但是不直接使用，但是又一个直接声明得控制器为：)\n"),_("ul",[_("li",[e._v("Deployment 控制器使用较多，但是仅能管理那些无状态得应用\n"),_("ul",[_("li",[e._v("Deployment 二级 控制器  HPA（HorizontalPodAutoscaler）  水平Pod自动伸缩控制器")])])])])]),e._v(" "),_("li",[e._v("StatefulSet   有状态控制器")]),e._v(" "),_("li",[e._v("DaemonSet 在每个Node上运行一个副本而不是随意运行")]),e._v(" "),_("li",[e._v("Job 运行作业")]),e._v(" "),_("li",[e._v("CronJob 周期性任务运行作业")])])])])])]),e._v(" "),_("p",[_("strong",[e._v("1、K8S中的对象单元介绍")])]),e._v(" "),_("ul",[_("li",[e._v("Pod：K8S中的最小部署单元，一个Pod由一个或多个容器组成，由于每个容器共享了pod网络和存储卷，所以端口不能冲突")]),e._v(" "),_("li",[e._v("Service：为提供相同服务的一个多或个Pod定义一个endpoint访问入口，还会分配一个集群IP。")]),e._v(" "),_("li",[e._v("Lable：标签，用于区分Pod、Service等对象，每个对象可以有多个标签")]),e._v(" "),_("li",[e._v("Deployment：Pod控制器的一种，主要用于无状态服务。它可以通过管理ReplicaSet（RS）以确保容器应用的副本数始终保持在用户定义的副本数，当容器异常退出会自动创建新的Pod来替代。RS是ReplicationController（RC）的升级版")]),e._v(" "),_("li",[e._v("StatefulSet：为了解决有状态服务的问题，对应Deployment")]),e._v(" "),_("li",[e._v("DaemonSet：确保全部Node上都运行一个Pod，适用于运行日志程序或者监控程序")])]),e._v(" "),_("p",[_("strong",[e._v("2、中心节点（Master）4个核心组件介绍")])]),e._v(" "),_("ul",[_("li",[e._v("API Server：整个系统的对外接口，是所有服务访问统一入口")]),e._v(" "),_("li",[e._v("Controller-Manager：集群大管家，管理所有Pod的运行状态，保证它们按照预定的配置去运行，比如Pod占用的资源、运行多长时间等")]),e._v(" "),_("li",[e._v("ETCD：可以理解为K8S的数据库或者注册中心，记录了网络资源等信息，ETCD需要配置高可用并支持https")]),e._v(" "),_("li",[e._v("Scheduler：负责对集群内部的资源进行调度，根据一个优选策略对Pod的分部进行调度")])]),e._v(" "),_("p",[_("strong",[e._v("3、运算节点（Node）核心组件介绍")])]),e._v(" "),_("ul",[_("li",[e._v("kubelet：负责与底层的Docker进行交互")]),e._v(" "),_("li",[e._v("kube-proxy：生成ipvs或iptables规则实现服务映射与负载均衡")]),e._v(" "),_("li",[e._v("docker：负责创建容器")])]),e._v(" "),_("p",[_("strong",[e._v("4、其他重要组件介绍")])]),e._v(" "),_("ul",[_("li",[e._v("flannel：网络组件，让集群中的不同宿主所创建的容器都有一个全集群唯一的IP地址，实现Pod跨主机通信")]),e._v(" "),_("li",[e._v("coredns：为集群中的Service创建名称并进行解析")]),e._v(" "),_("li",[e._v("traefik：Ingress的一种软件实现方式")]),e._v(" "),_("li",[e._v("ingress：官方实现4层代理，ingress可以实现7层代理。Ingress会把K8S中的服务顶出来，这样就可以让外部的其他服务（比如KVM）能调用K8S中的服务。和Service有点类似，只不过Service是对内部而言，Ingress是对外部而言。")])])])}),[],!1,null,null,null);v.default=o.exports}}]);